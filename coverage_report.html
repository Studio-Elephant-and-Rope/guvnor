
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>config: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/Studio-Elephant-and-Rope/guvnor/internal/config/config.go (96.1%)</option>
				
				<option value="file1">github.com/Studio-Elephant-and-Rope/guvnor/internal/core/domain/incident.go (99.0%)</option>
				
				<option value="file2">github.com/Studio-Elephant-and-Rope/guvnor/internal/core/ports/repositories.go (100.0%)</option>
				
				<option value="file3">github.com/Studio-Elephant-and-Rope/guvnor/internal/core/services/incident_service.go (95.0%)</option>
				
				<option value="file4">github.com/Studio-Elephant-and-Rope/guvnor/internal/logging/logger.go (94.5%)</option>
				
				<option value="file5">github.com/Studio-Elephant-and-Rope/guvnor/internal/middleware/logging.go (100.0%)</option>
				
				<option value="file6">github.com/Studio-Elephant-and-Rope/guvnor/internal/middleware/request_id.go (95.7%)</option>
				
				<option value="file7">github.com/Studio-Elephant-and-Rope/guvnor/internal/server/server.go (91.2%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Package config provides configuration management for the Guvnor incident management platform.
//
// This package handles loading configuration from multiple sources with proper precedence:
// 1. Environment variables (GUVNOR_*)
// 2. Configuration file (YAML)
// 3. Default values
//
// The configuration system uses Viper for flexible configuration management,
// supporting various formats and sources while maintaining backwards compatibility.
package config

import (
        "fmt"
        "os"
        "strings"

        "github.com/spf13/viper"
)

// Config represents the complete application configuration.
//
// This is the root configuration structure that contains all subsystem
// configurations. Each subsystem should have its own configuration struct
// to maintain separation of concerns.
type Config struct {
        Server    ServerConfig    `mapstructure:"server" yaml:"server"`
        Storage   StorageConfig   `mapstructure:"storage" yaml:"storage"`
        Telemetry TelemetryConfig `mapstructure:"telemetry" yaml:"telemetry"`
}

// ServerConfig contains HTTP server configuration.
type ServerConfig struct {
        // Host is the interface to bind the server to
        Host string `mapstructure:"host" yaml:"host"`
        // Port is the port number to listen on
        Port int `mapstructure:"port" yaml:"port"`
        // ReadTimeout is the maximum duration for reading the entire request
        ReadTimeoutSeconds int `mapstructure:"read_timeout_seconds" yaml:"read_timeout_seconds"`
        // WriteTimeout is the maximum duration before timing out writes
        WriteTimeoutSeconds int `mapstructure:"write_timeout_seconds" yaml:"write_timeout_seconds"`
        // IdleTimeout is the maximum time to wait for the next request when keep-alives are enabled
        IdleTimeoutSeconds int `mapstructure:"idle_timeout_seconds" yaml:"idle_timeout_seconds"`
}

// StorageConfig contains database and storage configuration.
type StorageConfig struct {
        // Type specifies the storage backend (postgres, sqlite, etc.)
        Type string `mapstructure:"type" yaml:"type"`
        // DSN is the data source name / connection string
        DSN string `mapstructure:"dsn" yaml:"dsn"`
        // MaxOpenConnections is the maximum number of open connections to the database
        MaxOpenConnections int `mapstructure:"max_open_connections" yaml:"max_open_connections"`
        // MaxIdleConnections is the maximum number of connections in the idle connection pool
        MaxIdleConnections int `mapstructure:"max_idle_connections" yaml:"max_idle_connections"`
        // ConnectionMaxLifetimeMinutes is the maximum time a connection may be reused
        ConnectionMaxLifetimeMinutes int `mapstructure:"connection_max_lifetime_minutes" yaml:"connection_max_lifetime_minutes"`
}

// TelemetryConfig contains observability configuration.
type TelemetryConfig struct {
        // Enabled determines whether telemetry is active
        Enabled bool `mapstructure:"enabled" yaml:"enabled"`
        // ServiceName is the name used to identify this service in traces
        ServiceName string `mapstructure:"service_name" yaml:"service_name"`
        // ServiceVersion is the version of this service for telemetry
        ServiceVersion string `mapstructure:"service_version" yaml:"service_version"`
        // Endpoint is the OpenTelemetry collector endpoint
        Endpoint string `mapstructure:"endpoint" yaml:"endpoint"`
        // SampleRate is the fraction of traces to sample (0.0 to 1.0)
        SampleRate float64 `mapstructure:"sample_rate" yaml:"sample_rate"`
}

// DefaultConfig returns a configuration with sensible defaults.
//
// These defaults are suitable for development and testing environments.
// Production deployments should override these values through configuration
// files or environment variables.
func DefaultConfig() *Config <span class="cov8" title="1">{
        return &amp;Config{
                Server: ServerConfig{
                        Host:                "0.0.0.0",
                        Port:                8080,
                        ReadTimeoutSeconds:  30,
                        WriteTimeoutSeconds: 30,
                        IdleTimeoutSeconds:  120,
                },
                Storage: StorageConfig{
                        Type:                         "sqlite",
                        DSN:                          "file:guvnor.db?cache=shared&amp;mode=rwc",
                        MaxOpenConnections:           25,
                        MaxIdleConnections:           5,
                        ConnectionMaxLifetimeMinutes: 5,
                },
                Telemetry: TelemetryConfig{
                        Enabled:        false,
                        ServiceName:    "guvnor",
                        ServiceVersion: "development",
                        Endpoint:       "",
                        SampleRate:     0.1,
                },
        }
}</span>

// Load loads configuration from multiple sources with proper precedence.
//
// Configuration is loaded in this order of precedence:
//  1. Environment variables (GUVNOR_*)
//  2. Configuration file (if specified)
//  3. Default values
//
// Returns a fully populated Config struct or an error if loading fails.
func Load(configFile string) (*Config, error) <span class="cov8" title="1">{
        // Start with default configuration
        config := DefaultConfig()

        // Create a new viper instance
        v := viper.New()

        // Set up environment variable handling
        v.SetEnvPrefix("GUVNOR")
        v.SetEnvKeyReplacer(strings.NewReplacer(".", "_"))
        v.AutomaticEnv()

        // Configure viper with our defaults
        if err := setDefaults(v, config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to set default configuration: %w", err)
        }</span>

        // Load configuration file if specified
        <span class="cov8" title="1">if configFile != "" </span><span class="cov8" title="1">{
                if err := loadConfigFile(v, configFile); err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("failed to load config file %s: %w", configFile, err)
                }</span>
        }

        // Unmarshal into our config struct
        <span class="cov8" title="1">if err := v.Unmarshal(config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal configuration: %w", err)
        }</span>

        // Validate the configuration
        <span class="cov8" title="1">if err := config.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("configuration validation failed: %w", err)
        }</span>

        <span class="cov8" title="1">return config, nil</span>
}

// setDefaults configures viper with default values from our config struct.
func setDefaults(v *viper.Viper, config *Config) error <span class="cov8" title="1">{
        // Server defaults
        v.SetDefault("server.host", config.Server.Host)
        v.SetDefault("server.port", config.Server.Port)
        v.SetDefault("server.read_timeout_seconds", config.Server.ReadTimeoutSeconds)
        v.SetDefault("server.write_timeout_seconds", config.Server.WriteTimeoutSeconds)
        v.SetDefault("server.idle_timeout_seconds", config.Server.IdleTimeoutSeconds)

        // Storage defaults
        v.SetDefault("storage.type", config.Storage.Type)
        v.SetDefault("storage.dsn", config.Storage.DSN)
        v.SetDefault("storage.max_open_connections", config.Storage.MaxOpenConnections)
        v.SetDefault("storage.max_idle_connections", config.Storage.MaxIdleConnections)
        v.SetDefault("storage.connection_max_lifetime_minutes", config.Storage.ConnectionMaxLifetimeMinutes)

        // Telemetry defaults
        v.SetDefault("telemetry.enabled", config.Telemetry.Enabled)
        v.SetDefault("telemetry.service_name", config.Telemetry.ServiceName)
        v.SetDefault("telemetry.service_version", config.Telemetry.ServiceVersion)
        v.SetDefault("telemetry.endpoint", config.Telemetry.Endpoint)
        v.SetDefault("telemetry.sample_rate", config.Telemetry.SampleRate)

        return nil
}</span>

// loadConfigFile loads configuration from a YAML file.
func loadConfigFile(v *viper.Viper, configFile string) error <span class="cov8" title="1">{
        // Check if file exists
        if _, err := os.Stat(configFile); os.IsNotExist(err) </span><span class="cov8" title="1">{
                return fmt.Errorf("configuration file does not exist: %s", configFile)
        }</span>

        // Set config file path
        <span class="cov8" title="1">v.SetConfigFile(configFile)

        // Read configuration
        if err := v.ReadInConfig(); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to read configuration file: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Validate checks that the configuration is valid and complete.
//
// This method performs comprehensive validation of all configuration values,
// ensuring they are within acceptable ranges and that required fields are set.
//
// Returns an error describing the first validation failure encountered.
func (c *Config) Validate() error <span class="cov8" title="1">{
        // Validate server configuration
        if err := c.Server.Validate(); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("server configuration invalid: %w", err)
        }</span>

        // Validate storage configuration
        <span class="cov8" title="1">if err := c.Storage.Validate(); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("storage configuration invalid: %w", err)
        }</span>

        // Validate telemetry configuration
        <span class="cov8" title="1">if err := c.Telemetry.Validate(); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("telemetry configuration invalid: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Validate checks server configuration for validity.
func (s *ServerConfig) Validate() error <span class="cov8" title="1">{
        if s.Port &lt; 1 || s.Port &gt; 65535 </span><span class="cov8" title="1">{
                return fmt.Errorf("port must be between 1 and 65535, got %d", s.Port)
        }</span>

        <span class="cov8" title="1">if s.ReadTimeoutSeconds &lt; 1 </span><span class="cov8" title="1">{
                return fmt.Errorf("read timeout must be positive, got %d", s.ReadTimeoutSeconds)
        }</span>

        <span class="cov8" title="1">if s.WriteTimeoutSeconds &lt; 1 </span><span class="cov8" title="1">{
                return fmt.Errorf("write timeout must be positive, got %d", s.WriteTimeoutSeconds)
        }</span>

        <span class="cov8" title="1">if s.IdleTimeoutSeconds &lt; 1 </span><span class="cov8" title="1">{
                return fmt.Errorf("idle timeout must be positive, got %d", s.IdleTimeoutSeconds)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Validate checks storage configuration for validity.
func (s *StorageConfig) Validate() error <span class="cov8" title="1">{
        if s.Type == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("storage type is required")
        }</span>

        <span class="cov8" title="1">if s.DSN == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("storage DSN is required")
        }</span>

        <span class="cov8" title="1">if s.MaxOpenConnections &lt; 1 </span><span class="cov8" title="1">{
                return fmt.Errorf("max open connections must be positive, got %d", s.MaxOpenConnections)
        }</span>

        <span class="cov8" title="1">if s.MaxIdleConnections &lt; 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("max idle connections cannot be negative, got %d", s.MaxIdleConnections)
        }</span>

        <span class="cov8" title="1">if s.MaxIdleConnections &gt; s.MaxOpenConnections </span><span class="cov8" title="1">{
                return fmt.Errorf("max idle connections (%d) cannot exceed max open connections (%d)",
                        s.MaxIdleConnections, s.MaxOpenConnections)
        }</span>

        <span class="cov8" title="1">if s.ConnectionMaxLifetimeMinutes &lt; 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("connection max lifetime cannot be negative, got %d", s.ConnectionMaxLifetimeMinutes)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Validate checks telemetry configuration for validity.
func (t *TelemetryConfig) Validate() error <span class="cov8" title="1">{
        if t.ServiceName == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("service name is required")
        }</span>

        <span class="cov8" title="1">if t.ServiceVersion == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("service version is required")
        }</span>

        <span class="cov8" title="1">if t.SampleRate &lt; 0.0 || t.SampleRate &gt; 1.0 </span><span class="cov8" title="1">{
                return fmt.Errorf("sample rate must be between 0.0 and 1.0, got %f", t.SampleRate)
        }</span>

        // If telemetry is enabled, endpoint should be specified
        <span class="cov8" title="1">if t.Enabled &amp;&amp; t.Endpoint == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("telemetry endpoint is required when telemetry is enabled")
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Package domain contains the core domain models for the Guvnor incident management platform.
//
// This package defines the fundamental types and business logic for incidents,
// signals, and events without any external dependencies.
package domain

import (
        "errors"
        "fmt"
        "time"
)

// Status represents the current state of an incident.
type Status string

// Status constants define the valid incident statuses and their transitions.
const (
        StatusTriggered     Status = "triggered"
        StatusAcknowledged  Status = "acknowledged"
        StatusInvestigating Status = "investigating"
        StatusResolved      Status = "resolved"
)

// String returns the string representation of the status.
func (s Status) String() string <span class="cov8" title="1">{
        return string(s)
}</span>

// IsValid checks if the status is one of the defined valid statuses.
func (s Status) IsValid() bool <span class="cov8" title="1">{
        switch s </span>{
        case StatusTriggered, StatusAcknowledged, StatusInvestigating, StatusResolved:<span class="cov8" title="1">
                return true</span>
        default:<span class="cov8" title="1">
                return false</span>
        }
}

// Severity represents the criticality level of an incident.
type Severity string

// Severity constants define the valid incident severity levels.
const (
        SeverityCritical Severity = "critical"
        SeverityHigh     Severity = "high"
        SeverityMedium   Severity = "medium"
        SeverityLow      Severity = "low"
        SeverityInfo     Severity = "info"
)

// String returns the string representation of the severity.
func (s Severity) String() string <span class="cov8" title="1">{
        return string(s)
}</span>

// IsValid checks if the severity is one of the defined valid severities.
func (s Severity) IsValid() bool <span class="cov8" title="1">{
        switch s </span>{
        case SeverityCritical, SeverityHigh, SeverityMedium, SeverityLow, SeverityInfo:<span class="cov8" title="1">
                return true</span>
        default:<span class="cov8" title="1">
                return false</span>
        }
}

// ChannelType represents the notification channel type.
type ChannelType string

// ChannelType constants define the valid notification channels.
const (
        ChannelTypeEmail     ChannelType = "email"
        ChannelTypeSlack     ChannelType = "slack"
        ChannelTypeSMS       ChannelType = "sms"
        ChannelTypeWebhook   ChannelType = "webhook"
        ChannelTypePagerDuty ChannelType = "pagerduty"
)

// String returns the string representation of the channel type.
func (c ChannelType) String() string <span class="cov8" title="1">{
        return string(c)
}</span>

// IsValid checks if the channel type is one of the defined valid types.
func (c ChannelType) IsValid() bool <span class="cov8" title="1">{
        switch c </span>{
        case ChannelTypeEmail, ChannelTypeSlack, ChannelTypeSMS, ChannelTypeWebhook, ChannelTypePagerDuty:<span class="cov8" title="1">
                return true</span>
        default:<span class="cov8" title="1">
                return false</span>
        }
}

// Signal represents an incoming alert or notification that can trigger an incident.
type Signal struct {
        ID          string                 `json:"id"`
        Source      string                 `json:"source"`
        Title       string                 `json:"title"`
        Description string                 `json:"description"`
        Severity    Severity               `json:"severity"`
        Labels      map[string]string      `json:"labels"`
        Annotations map[string]string      `json:"annotations"`
        Payload     map[string]interface{} `json:"payload"`
        ReceivedAt  time.Time              `json:"received_at"`
}

// Validate checks if the signal has all required fields and valid values.
//
// Returns an error if validation fails, detailing what is invalid.
func (s *Signal) Validate() error <span class="cov8" title="1">{
        if s.ID == "" </span><span class="cov8" title="1">{
                return errors.New("signal ID is required")
        }</span>
        <span class="cov8" title="1">if s.Source == "" </span><span class="cov8" title="1">{
                return errors.New("signal source is required")
        }</span>
        <span class="cov8" title="1">if s.Title == "" </span><span class="cov8" title="1">{
                return errors.New("signal title is required")
        }</span>
        <span class="cov8" title="1">if !s.Severity.IsValid() </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid severity: %s", s.Severity)
        }</span>
        <span class="cov8" title="1">if s.ReceivedAt.IsZero() </span><span class="cov8" title="1">{
                return errors.New("signal received_at timestamp is required")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Event represents a recorded action or change within an incident.
type Event struct {
        ID          string                 `json:"id"`
        IncidentID  string                 `json:"incident_id"`
        Type        string                 `json:"type"`
        Actor       string                 `json:"actor"`
        Description string                 `json:"description"`
        Metadata    map[string]interface{} `json:"metadata"`
        OccurredAt  time.Time              `json:"occurred_at"`
}

// Validate checks if the event has all required fields.
//
// Returns an error if validation fails, detailing what is invalid.
func (e *Event) Validate() error <span class="cov8" title="1">{
        if e.ID == "" </span><span class="cov8" title="1">{
                return errors.New("event ID is required")
        }</span>
        <span class="cov8" title="1">if e.IncidentID == "" </span><span class="cov8" title="1">{
                return errors.New("event incident_id is required")
        }</span>
        <span class="cov8" title="1">if e.Type == "" </span><span class="cov8" title="1">{
                return errors.New("event type is required")
        }</span>
        <span class="cov8" title="1">if e.Actor == "" </span><span class="cov8" title="1">{
                return errors.New("event actor is required")
        }</span>
        <span class="cov8" title="1">if e.OccurredAt.IsZero() </span><span class="cov8" title="1">{
                return errors.New("event occurred_at timestamp is required")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Incident represents a service disruption or issue that requires attention.
type Incident struct {
        ID          string            `json:"id"`
        Title       string            `json:"title"`
        Description string            `json:"description"`
        Status      Status            `json:"status"`
        Severity    Severity          `json:"severity"`
        TeamID      string            `json:"team_id"`
        AssigneeID  string            `json:"assignee_id,omitempty"`
        ServiceID   string            `json:"service_id,omitempty"`
        Labels      map[string]string `json:"labels,omitempty"`
        CreatedAt   time.Time         `json:"created_at"`
        UpdatedAt   time.Time         `json:"updated_at"`
        ResolvedAt  *time.Time        `json:"resolved_at,omitempty"`

        // Related entities
        Signals []Signal `json:"signals,omitempty"`
        Events  []Event  `json:"events,omitempty"`
}

// Validate checks if the incident has all required fields and valid values.
//
// Returns an error if validation fails, detailing what is invalid.
//
// Possible errors:
//   - ErrMissingID: incident ID is empty
//   - ErrMissingTitle: incident title is empty
//   - ErrInvalidStatus: status is not one of the valid statuses
//   - ErrInvalidSeverity: severity is not one of the valid severities
//   - ErrMissingTeam: team ID is empty
//   - ErrInvalidTimestamp: created_at or updated_at is zero
func (i *Incident) Validate() error <span class="cov8" title="1">{
        if i.ID == "" </span><span class="cov8" title="1">{
                return errors.New("incident ID is required")
        }</span>
        <span class="cov8" title="1">if i.Title == "" </span><span class="cov8" title="1">{
                return errors.New("incident title is required")
        }</span>
        <span class="cov8" title="1">if i.Title != "" &amp;&amp; len(i.Title) &gt; 200 </span><span class="cov8" title="1">{
                return errors.New("incident title exceeds maximum length of 200 characters")
        }</span>
        <span class="cov8" title="1">if !i.Status.IsValid() </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid status: %s", i.Status)
        }</span>
        <span class="cov8" title="1">if !i.Severity.IsValid() </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid severity: %s", i.Severity)
        }</span>
        <span class="cov8" title="1">if i.TeamID == "" </span><span class="cov8" title="1">{
                return errors.New("incident team_id is required")
        }</span>
        <span class="cov8" title="1">if i.CreatedAt.IsZero() </span><span class="cov8" title="1">{
                return errors.New("incident created_at timestamp is required")
        }</span>
        <span class="cov8" title="1">if i.UpdatedAt.IsZero() </span><span class="cov8" title="1">{
                return errors.New("incident updated_at timestamp is required")
        }</span>
        <span class="cov8" title="1">if i.UpdatedAt.Before(i.CreatedAt) </span><span class="cov8" title="1">{
                return errors.New("incident updated_at cannot be before created_at")
        }</span>
        <span class="cov8" title="1">if i.Status == StatusResolved &amp;&amp; i.ResolvedAt == nil </span><span class="cov8" title="1">{
                return errors.New("resolved incidents must have a resolved_at timestamp")
        }</span>
        <span class="cov8" title="1">if i.Status != StatusResolved &amp;&amp; i.ResolvedAt != nil </span><span class="cov8" title="1">{
                return errors.New("only resolved incidents can have a resolved_at timestamp")
        }</span>

        // Validate attached signals
        <span class="cov8" title="1">for idx, signal := range i.Signals </span><span class="cov8" title="1">{
                if err := signal.Validate(); err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("invalid signal at index %d: %w", idx, err)
                }</span>
        }

        // Validate attached events
        <span class="cov8" title="1">for idx, event := range i.Events </span><span class="cov8" title="1">{
                if err := event.Validate(); err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("invalid event at index %d: %w", idx, err)
                }</span>
                <span class="cov8" title="1">if event.IncidentID != i.ID </span><span class="cov8" title="1">{
                        return fmt.Errorf("event at index %d has mismatched incident_id", idx)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// CanTransitionTo checks if the incident can transition from its current status to the target status.
//
// Valid transitions:
//   - triggered → acknowledged
//   - triggered → investigating
//   - triggered → resolved
//   - acknowledged → investigating
//   - acknowledged → resolved
//   - investigating → resolved
//   - Any valid status → triggered (reopening)
//
// Returns true if the transition is valid, false otherwise.
func (i *Incident) CanTransitionTo(targetStatus Status) bool <span class="cov8" title="1">{
        if !targetStatus.IsValid() </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">if !i.Status.IsValid() </span><span class="cov8" title="1">{
                return false
        }</span>

        // Same status is always valid (no-op)
        <span class="cov8" title="1">if i.Status == targetStatus </span><span class="cov8" title="1">{
                return true
        }</span>

        // Can always reopen an incident (transition to triggered) from valid statuses
        <span class="cov8" title="1">if targetStatus == StatusTriggered </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">switch i.Status </span>{
        case StatusTriggered:<span class="cov8" title="1">
                // From triggered, can go to acknowledged, investigating, or resolved
                return targetStatus == StatusAcknowledged ||
                        targetStatus == StatusInvestigating ||
                        targetStatus == StatusResolved</span>
        case StatusAcknowledged:<span class="cov8" title="1">
                // From acknowledged, can go to investigating or resolved
                return targetStatus == StatusInvestigating ||
                        targetStatus == StatusResolved</span>
        case StatusInvestigating:<span class="cov8" title="1">
                // From investigating, can only go to resolved
                return targetStatus == StatusResolved</span>
        case StatusResolved:<span class="cov8" title="1">
                // From resolved, can only go to triggered (reopening)
                return targetStatus == StatusTriggered</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

// AttachSignal adds a signal to the incident if it's not already attached.
//
// The signal is validated before attachment. If validation fails,
// an error is returned and the signal is not attached.
func (i *Incident) AttachSignal(signal Signal) error <span class="cov8" title="1">{
        if err := signal.Validate(); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("cannot attach invalid signal: %w", err)
        }</span>

        // Check if signal is already attached
        <span class="cov8" title="1">for _, existingSignal := range i.Signals </span><span class="cov8" title="1">{
                if existingSignal.ID == signal.ID </span><span class="cov8" title="1">{
                        return nil // Signal already attached, no error
                }</span>
        }

        <span class="cov8" title="1">i.Signals = append(i.Signals, signal)
        i.UpdatedAt = time.Now().UTC()
        return nil</span>
}

// RecordEvent adds an event to the incident's history.
//
// The event is validated before recording. If validation fails,
// an error is returned and the event is not recorded.
// The event's incident_id is automatically set to match this incident.
func (i *Incident) RecordEvent(event Event) error <span class="cov8" title="1">{
        // Set the incident ID to ensure consistency
        event.IncidentID = i.ID

        if err := event.Validate(); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("cannot record invalid event: %w", err)
        }</span>

        <span class="cov8" title="1">i.Events = append(i.Events, event)
        i.UpdatedAt = time.Now().UTC()
        return nil</span>
}

// TransitionTo changes the incident status to the target status if the transition is valid.
//
// This method automatically handles side effects of status transitions:
//   - Sets resolved_at timestamp when transitioning to resolved
//   - Clears resolved_at timestamp when transitioning away from resolved
//   - Updates the updated_at timestamp
//   - Records a status change event
//
// Returns an error if the transition is invalid or if recording the event fails.
func (i *Incident) TransitionTo(targetStatus Status, actor string) error <span class="cov8" title="1">{
        if !i.CanTransitionTo(targetStatus) </span><span class="cov8" title="1">{
                return fmt.Errorf("cannot transition from %s to %s", i.Status, targetStatus)
        }</span>

        <span class="cov8" title="1">oldStatus := i.Status
        i.Status = targetStatus
        i.UpdatedAt = time.Now().UTC()

        // Handle resolved status side effects
        if targetStatus == StatusResolved &amp;&amp; i.ResolvedAt == nil </span><span class="cov8" title="1">{
                now := time.Now().UTC()
                i.ResolvedAt = &amp;now
        }</span> else<span class="cov8" title="1"> if targetStatus != StatusResolved &amp;&amp; i.ResolvedAt != nil </span><span class="cov8" title="1">{
                i.ResolvedAt = nil
        }</span>

        // Record status change event
        <span class="cov8" title="1">event := Event{
                ID:          fmt.Sprintf("evt_%d", time.Now().UnixNano()),
                Type:        "status_changed",
                Actor:       actor,
                Description: fmt.Sprintf("Status changed from %s to %s", oldStatus, targetStatus),
                Metadata: map[string]interface{}{
                        "old_status": oldStatus.String(),
                        "new_status": targetStatus.String(),
                },
                OccurredAt: i.UpdatedAt,
        }

        return i.RecordEvent(event)</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// Package ports defines the interfaces that connect the core domain to external adapters.
//
// This package contains port interfaces that define contracts for external dependencies
// such as databases, message queues, and other infrastructure components. Following
// hexagonal architecture principles, these interfaces allow the core domain to remain
// independent of external concerns.
package ports

import (
        "context"
        "errors"
        "time"

        "github.com/Studio-Elephant-and-Rope/guvnor/internal/core/domain"
)

// Common repository errors that implementations should use for consistent error handling.
var (
        // ErrNotFound indicates that a requested resource was not found.
        ErrNotFound = errors.New("resource not found")

        // ErrAlreadyExists indicates that a resource already exists and cannot be created again.
        ErrAlreadyExists = errors.New("resource already exists")

        // ErrConflict indicates that the operation conflicts with the current state of the resource.
        ErrConflict = errors.New("resource conflict")

        // ErrInvalidInput indicates that the provided input is invalid.
        ErrInvalidInput = errors.New("invalid input")

        // ErrConnectionFailed indicates that the storage connection failed.
        ErrConnectionFailed = errors.New("storage connection failed")

        // ErrTimeout indicates that the operation timed out.
        ErrTimeout = errors.New("operation timed out")
)

// ListFilter defines filtering and pagination options for listing incidents.
//
// This struct provides comprehensive filtering capabilities while maintaining
// good performance through proper indexing strategies.
type ListFilter struct {
        // TeamID filters incidents by team ownership
        TeamID string `json:"team_id,omitempty"`

        // Status filters incidents by their current status
        Status []domain.Status `json:"status,omitempty"`

        // Severity filters incidents by severity level
        Severity []domain.Severity `json:"severity,omitempty"`

        // AssigneeID filters incidents by assignee
        AssigneeID string `json:"assignee_id,omitempty"`

        // ServiceID filters incidents by affected service
        ServiceID string `json:"service_id,omitempty"`

        // Labels filters incidents that have all specified labels
        Labels map[string]string `json:"labels,omitempty"`

        // CreatedAfter filters incidents created after this time
        CreatedAfter *time.Time `json:"created_after,omitempty"`

        // CreatedBefore filters incidents created before this time
        CreatedBefore *time.Time `json:"created_before,omitempty"`

        // UpdatedAfter filters incidents updated after this time
        UpdatedAfter *time.Time `json:"updated_after,omitempty"`

        // UpdatedBefore filters incidents updated before this time
        UpdatedBefore *time.Time `json:"updated_before,omitempty"`

        // Search performs text search on title and description
        Search string `json:"search,omitempty"`

        // Limit sets the maximum number of results to return (default: 50, max: 1000)
        Limit int `json:"limit,omitempty"`

        // Offset sets the number of results to skip for pagination
        Offset int `json:"offset,omitempty"`

        // SortBy specifies the field to sort by (created_at, updated_at, severity)
        SortBy string `json:"sort_by,omitempty"`

        // SortOrder specifies the sort direction (asc, desc)
        SortOrder string `json:"sort_order,omitempty"`
}

// Validate checks if the ListFilter parameters are valid and sets defaults.
//
// Returns an error if any filter parameters are invalid or out of acceptable ranges.
func (f *ListFilter) Validate() error <span class="cov8" title="1">{
        // Set default limit if not specified
        if f.Limit &lt;= 0 </span><span class="cov8" title="1">{
                f.Limit = 50
        }</span>

        // Enforce maximum limit
        <span class="cov8" title="1">if f.Limit &gt; 1000 </span><span class="cov8" title="1">{
                return ErrInvalidInput
        }</span>

        // Validate offset
        <span class="cov8" title="1">if f.Offset &lt; 0 </span><span class="cov8" title="1">{
                return ErrInvalidInput
        }</span>

        // Validate time ranges
        <span class="cov8" title="1">if f.CreatedAfter != nil &amp;&amp; f.CreatedBefore != nil &amp;&amp; f.CreatedAfter.After(*f.CreatedBefore) </span><span class="cov8" title="1">{
                return ErrInvalidInput
        }</span>

        <span class="cov8" title="1">if f.UpdatedAfter != nil &amp;&amp; f.UpdatedBefore != nil &amp;&amp; f.UpdatedAfter.After(*f.UpdatedBefore) </span><span class="cov8" title="1">{
                return ErrInvalidInput
        }</span>

        // Validate sort parameters
        <span class="cov8" title="1">if f.SortBy != "" </span><span class="cov8" title="1">{
                validSortFields := map[string]bool{
                        "created_at": true,
                        "updated_at": true,
                        "severity":   true,
                        "status":     true,
                }
                if !validSortFields[f.SortBy] </span><span class="cov8" title="1">{
                        return ErrInvalidInput
                }</span>
        } else<span class="cov8" title="1"> {
                f.SortBy = "created_at" // Default sort
        }</span>

        <span class="cov8" title="1">if f.SortOrder != "" </span><span class="cov8" title="1">{
                if f.SortOrder != "asc" &amp;&amp; f.SortOrder != "desc" </span><span class="cov8" title="1">{
                        return ErrInvalidInput
                }</span>
        } else<span class="cov8" title="1"> {
                f.SortOrder = "desc" // Default to newest first
        }</span>

        // Validate status values
        <span class="cov8" title="1">for _, status := range f.Status </span><span class="cov8" title="1">{
                if !status.IsValid() </span><span class="cov8" title="1">{
                        return ErrInvalidInput
                }</span>
        }

        // Validate severity values
        <span class="cov8" title="1">for _, severity := range f.Severity </span><span class="cov8" title="1">{
                if !severity.IsValid() </span><span class="cov8" title="1">{
                        return ErrInvalidInput
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// ListResult represents the result of a list operation with pagination metadata.
type ListResult struct {
        // Incidents contains the actual incident data
        Incidents []*domain.Incident `json:"incidents"`

        // Total is the total number of incidents matching the filter (ignoring pagination)
        Total int `json:"total"`

        // Limit is the limit that was applied
        Limit int `json:"limit"`

        // Offset is the offset that was applied
        Offset int `json:"offset"`

        // HasMore indicates if there are more results available
        HasMore bool `json:"has_more"`
}

// IncidentRepository defines the contract for incident storage operations.
//
// This interface abstracts the storage layer, allowing different implementations
// (PostgreSQL, SQLite, in-memory) while maintaining consistent behavior.
// All methods should handle context cancellation and timeouts appropriately.
type IncidentRepository interface {
        // Create stores a new incident in the repository.
        //
        // The incident must have a unique ID and pass domain validation.
        // Returns ErrAlreadyExists if an incident with the same ID already exists.
        // Returns ErrInvalidInput if the incident fails validation.
        //
        // Possible errors:
        //   - ErrAlreadyExists: incident with this ID already exists
        //   - ErrInvalidInput: incident fails validation
        //   - ErrConnectionFailed: storage system is unavailable
        //   - ErrTimeout: operation exceeded context deadline
        Create(ctx context.Context, incident *domain.Incident) error

        // Get retrieves an incident by its unique identifier.
        //
        // Returns the complete incident including attached signals and events.
        // Returns ErrNotFound if no incident exists with the given ID.
        //
        // Possible errors:
        //   - ErrNotFound: incident does not exist
        //   - ErrConnectionFailed: storage system is unavailable
        //   - ErrTimeout: operation exceeded context deadline
        Get(ctx context.Context, id string) (*domain.Incident, error)

        // List retrieves incidents based on the provided filter criteria.
        //
        // Returns a paginated list of incidents with metadata about the total count.
        // The filter is validated before execution.
        //
        // Possible errors:
        //   - ErrInvalidInput: filter parameters are invalid
        //   - ErrConnectionFailed: storage system is unavailable
        //   - ErrTimeout: operation exceeded context deadline
        List(ctx context.Context, filter ListFilter) (*ListResult, error)

        // Update modifies an existing incident in the repository.
        //
        // The incident must exist and pass domain validation.
        // This operation updates the entire incident record.
        // Returns ErrNotFound if the incident doesn't exist.
        // Returns ErrConflict if the incident has been modified by another process.
        //
        // Possible errors:
        //   - ErrNotFound: incident does not exist
        //   - ErrInvalidInput: incident fails validation
        //   - ErrConflict: incident was modified by another process
        //   - ErrConnectionFailed: storage system is unavailable
        //   - ErrTimeout: operation exceeded context deadline
        Update(ctx context.Context, incident *domain.Incident) error

        // AddEvent appends an event to an incident's history.
        //
        // The event must be valid and reference an existing incident.
        // Events are append-only and cannot be modified once created.
        // Returns ErrNotFound if the referenced incident doesn't exist.
        //
        // Possible errors:
        //   - ErrNotFound: referenced incident does not exist
        //   - ErrInvalidInput: event fails validation
        //   - ErrConnectionFailed: storage system is unavailable
        //   - ErrTimeout: operation exceeded context deadline
        AddEvent(ctx context.Context, event *domain.Event) error

        // Delete removes an incident from the repository.
        //
        // This is a soft delete operation that marks the incident as deleted
        // but preserves the data for audit purposes. Related events and signals
        // are also marked as deleted.
        // Returns ErrNotFound if the incident doesn't exist.
        //
        // Possible errors:
        //   - ErrNotFound: incident does not exist
        //   - ErrConnectionFailed: storage system is unavailable
        //   - ErrTimeout: operation exceeded context deadline
        Delete(ctx context.Context, id string) error

        // GetWithEvents retrieves an incident with its complete event history.
        //
        // This is optimized for cases where the full incident context is needed.
        // Events are ordered by occurred_at timestamp.
        // Returns ErrNotFound if no incident exists with the given ID.
        //
        // Possible errors:
        //   - ErrNotFound: incident does not exist
        //   - ErrConnectionFailed: storage system is unavailable
        //   - ErrTimeout: operation exceeded context deadline
        GetWithEvents(ctx context.Context, id string) (*domain.Incident, error)

        // GetWithSignals retrieves an incident with its attached signals.
        //
        // This is optimized for cases where signal correlation is needed.
        // Signals are ordered by received_at timestamp.
        // Returns ErrNotFound if no incident exists with the given ID.
        //
        // Possible errors:
        //   - ErrNotFound: incident does not exist
        //   - ErrConnectionFailed: storage system is unavailable
        //   - ErrTimeout: operation exceeded context deadline
        GetWithSignals(ctx context.Context, id string) (*domain.Incident, error)
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// Package services provides business logic orchestration for the Guvnor incident management platform.
//
// This package contains service implementations that coordinate between domain objects
// and repository interfaces. Services handle business rules, validation, event generation,
// and cross-cutting concerns like logging and metrics.
//
// All services follow dependency injection patterns and are designed for testability
// with proper error handling and context awareness.
package services

import (
        "context"
        "fmt"
        "strconv"
        "sync"
        "time"

        "github.com/google/uuid"

        "github.com/Studio-Elephant-and-Rope/guvnor/internal/core/domain"
        "github.com/Studio-Elephant-and-Rope/guvnor/internal/core/ports"
        "github.com/Studio-Elephant-and-Rope/guvnor/internal/logging"
)

// IncidentService orchestrates incident management business logic.
//
// This service handles all incident-related operations including creation, updates,
// status transitions, responder management, and event recording. It enforces
// business rules while delegating persistence to repository implementations.
//
// Key responsibilities:
//   - Incident creation with auto-generated identifiers
//   - Status transition validation and management
//   - Responder assignment and management
//   - Event recording for audit trails
//   - Business rule enforcement
//   - Cross-cutting concerns (logging, metrics)
//
// The service is designed for concurrent access and handles all edge cases
// gracefully with proper error responses.
type IncidentService struct {
        repo      ports.IncidentRepository
        logger    *logging.Logger
        idCounter *incidentCounter
}

// incidentCounter manages auto-generated incident identifiers.
//
// Incident IDs follow the format: INC-YYYY-NNN where:
//   - INC is the fixed prefix
//   - YYYY is the current year
//   - NNN is a zero-padded sequential number (001, 002, etc.)
//
// The counter is thread-safe and handles year rollovers automatically.
type incidentCounter struct {
        mu       sync.Mutex
        year     int
        sequence int
}

// NewIncidentService creates a new incident service with the provided dependencies.
//
// The service requires a repository implementation for persistence and a logger
// for structured logging. Both dependencies are required and the function will
// return an error if either is nil.
//
// Possible errors:
//   - ErrInvalidInput: repository or logger is nil
func NewIncidentService(repo ports.IncidentRepository, logger *logging.Logger) (*IncidentService, error) <span class="cov8" title="1">{
        if repo == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("%w: repository cannot be nil", ports.ErrInvalidInput)
        }</span>
        <span class="cov8" title="1">if logger == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("%w: logger cannot be nil", ports.ErrInvalidInput)
        }</span>

        <span class="cov8" title="1">return &amp;IncidentService{
                repo:   repo,
                logger: logger,
                idCounter: &amp;incidentCounter{
                        year:     time.Now().UTC().Year(),
                        sequence: 0,
                },
        }, nil</span>
}

// CreateIncident creates a new incident with the specified title and severity.
//
// This method handles the complete incident creation workflow:
//   - Generates a unique UUID and human-readable identifier
//   - Sets appropriate timestamps and initial status
//   - Validates the incident against domain rules
//   - Persists the incident via repository
//   - Records a creation event for audit trail
//   - Returns the fully populated incident
//
// The incident is created in "triggered" status and will have both a UUID
// for internal references and a human-readable ID (INC-2024-001 format)
// for external communication.
//
// Possible errors:
//   - ErrInvalidInput: title is empty, exceeds length limit, or severity is invalid
//   - ErrAlreadyExists: generated ID conflicts (highly unlikely)
//   - ErrConnectionFailed: repository is unavailable
//   - ErrTimeout: operation exceeded context deadline
func (s *IncidentService) CreateIncident(ctx context.Context, title, severity, teamID string) (*domain.Incident, error) <span class="cov8" title="1">{
        logger := s.logger.WithFields("operation", "create_incident", "title", title, "severity", severity, "team_id", teamID)
        logger.Debug("Creating new incident")

        // Validate inputs
        if title == "" </span><span class="cov8" title="1">{
                logger.Debug("Incident creation failed: empty title")
                return nil, fmt.Errorf("%w: title cannot be empty", ports.ErrInvalidInput)
        }</span>

        <span class="cov8" title="1">if len(title) &gt; 200 </span><span class="cov8" title="1">{
                logger.Debug("Incident creation failed: title too long")
                return nil, fmt.Errorf("%w: title exceeds maximum length of 200 characters", ports.ErrInvalidInput)
        }</span>

        <span class="cov8" title="1">if teamID == "" </span><span class="cov8" title="1">{
                logger.Debug("Incident creation failed: empty team ID")
                return nil, fmt.Errorf("%w: team ID cannot be empty", ports.ErrInvalidInput)
        }</span>

        // Parse and validate severity
        <span class="cov8" title="1">sev := domain.Severity(severity)
        if !sev.IsValid() </span><span class="cov8" title="1">{
                logger.WithFields("provided_severity", severity).Debug("Incident creation failed: invalid severity")
                return nil, fmt.Errorf("%w: invalid severity '%s', must be one of: critical, high, medium, low, info", ports.ErrInvalidInput, severity)
        }</span>

        // Generate identifiers
        <span class="cov8" title="1">id := uuid.New().String()
        humanID := s.generateHumanReadableID()

        // Set timestamps
        now := time.Now().UTC()

        // Create incident
        incident := &amp;domain.Incident{
                ID:          id,
                Title:       title,
                Description: fmt.Sprintf("Incident %s: %s", humanID, title),
                Status:      domain.StatusTriggered,
                Severity:    sev,
                TeamID:      teamID,
                CreatedAt:   now,
                UpdatedAt:   now,
                Labels:      map[string]string{"incident_id": humanID},
        }

        // Validate incident
        if err := incident.Validate(); err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("Incident validation failed")
                return nil, fmt.Errorf("%w: incident validation failed: %v", ports.ErrInvalidInput, err)
        }</span>

        // Store incident
        <span class="cov8" title="1">if err := s.repo.Create(ctx, incident); err != nil </span><span class="cov8" title="1">{
                logger.WithError(err).Error("Failed to store incident")
                return nil, err
        }</span>

        // Record creation event
        <span class="cov8" title="1">creationEvent := &amp;domain.Event{
                ID:          uuid.New().String(),
                IncidentID:  incident.ID,
                Type:        "incident_created",
                Actor:       "system", // Will be replaced with actual user when auth is implemented
                Description: fmt.Sprintf("Incident %s created with severity %s", humanID, severity),
                Metadata: map[string]interface{}{
                        "human_id":       humanID,
                        "initial_status": string(domain.StatusTriggered),
                        "severity":       string(sev),
                },
                OccurredAt: now,
        }

        if err := s.repo.AddEvent(ctx, creationEvent); err != nil </span><span class="cov8" title="1">{
                logger.WithError(err).Warn("Failed to record creation event")
                // Don't fail the operation for event recording failures
        }</span>

        <span class="cov8" title="1">logger.WithFields("incident_id", incident.ID, "human_id", humanID).Info("Incident created successfully")
        return incident, nil</span>
}

// GetIncident retrieves an incident by its unique identifier.
//
// This method fetches the complete incident including all attached signals
// and events. The incident is returned with its full audit trail and
// current state.
//
// Possible errors:
//   - ErrInvalidInput: id is empty
//   - ErrNotFound: incident does not exist
//   - ErrConnectionFailed: repository is unavailable
//   - ErrTimeout: operation exceeded context deadline
func (s *IncidentService) GetIncident(ctx context.Context, id string) (*domain.Incident, error) <span class="cov8" title="1">{
        if id == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("%w: incident ID cannot be empty", ports.ErrInvalidInput)
        }</span>

        <span class="cov8" title="1">logger := s.logger.WithFields("operation", "get_incident", "incident_id", id)
        logger.Debug("Retrieving incident")

        incident, err := s.repo.Get(ctx, id)
        if err != nil </span><span class="cov8" title="1">{
                logger.WithError(err).Error("Failed to retrieve incident")
                return nil, err
        }</span>

        <span class="cov8" title="1">logger.Debug("Incident retrieved successfully")
        return incident, nil</span>
}

// ListIncidents retrieves incidents based on the provided filter criteria.
//
// This method supports comprehensive filtering, sorting, and pagination
// of incidents. The filter is validated before execution to ensure
// proper query construction.
//
// Possible errors:
//   - ErrInvalidInput: filter parameters are invalid
//   - ErrConnectionFailed: repository is unavailable
//   - ErrTimeout: operation exceeded context deadline
func (s *IncidentService) ListIncidents(ctx context.Context, filter ports.ListFilter) (*ports.ListResult, error) <span class="cov8" title="1">{
        logger := s.logger.WithFields("operation", "list_incidents", "limit", filter.Limit, "offset", filter.Offset)
        logger.Debug("Listing incidents with filters")

        // Validate filter
        if err := filter.Validate(); err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Debug("Invalid filter parameters")
                return nil, err
        }</span>

        <span class="cov8" title="1">result, err := s.repo.List(ctx, filter)
        if err != nil </span><span class="cov8" title="1">{
                logger.WithError(err).Error("Failed to list incidents")
                return nil, err
        }</span>

        <span class="cov8" title="1">logger.WithFields("total", result.Total, "returned", len(result.Incidents)).Debug("Incidents listed successfully")
        return result, nil</span>
}

// UpdateStatus transitions an incident to a new status.
//
// This method enforces status transition rules defined in the domain model.
// Valid transitions are validated before applying the change, and an event
// is recorded for the audit trail.
//
// Valid status transitions:
//   - triggered → acknowledged, investigating, resolved
//   - acknowledged → investigating, resolved, triggered (reopen)
//   - investigating → resolved, triggered (reopen)
//   - resolved → triggered (reopen)
//
// Possible errors:
//   - ErrInvalidInput: incident ID is empty or status is invalid
//   - ErrNotFound: incident does not exist
//   - ErrConflict: status transition is not allowed or concurrent modification
//   - ErrConnectionFailed: repository is unavailable
//   - ErrTimeout: operation exceeded context deadline
func (s *IncidentService) UpdateStatus(ctx context.Context, id string, status domain.Status) error <span class="cov8" title="1">{
        if id == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("%w: incident ID cannot be empty", ports.ErrInvalidInput)
        }</span>

        <span class="cov8" title="1">if !status.IsValid() </span><span class="cov8" title="1">{
                return fmt.Errorf("%w: invalid status '%s'", ports.ErrInvalidInput, status)
        }</span>

        <span class="cov8" title="1">logger := s.logger.WithFields("operation", "update_status", "incident_id", id, "new_status", string(status))
        logger.Debug("Updating incident status")

        // Get current incident
        incident, err := s.repo.Get(ctx, id)
        if err != nil </span><span class="cov8" title="1">{
                logger.WithError(err).Error("Failed to retrieve incident for status update")
                return err
        }</span>

        <span class="cov8" title="1">oldStatus := incident.Status

        // Check if transition is valid
        if !incident.CanTransitionTo(status) </span><span class="cov8" title="1">{
                logger.WithFields("current_status", string(oldStatus), "target_status", string(status)).
                        Warn("Invalid status transition attempted")
                return fmt.Errorf("%w: cannot transition from %s to %s", ports.ErrConflict, oldStatus, status)
        }</span>

        // Apply status transition
        <span class="cov8" title="1">if err := incident.TransitionTo(status, "system"); err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("Failed to apply status transition")
                return fmt.Errorf("%w: status transition failed: %v", ports.ErrConflict, err)
        }</span>

        // Update incident
        <span class="cov8" title="1">if err := s.repo.Update(ctx, incident); err != nil </span><span class="cov8" title="1">{
                logger.WithError(err).Error("Failed to update incident status")
                return err
        }</span>

        // Record status change event
        <span class="cov8" title="1">statusEvent := &amp;domain.Event{
                ID:          uuid.New().String(),
                IncidentID:  incident.ID,
                Type:        "status_changed",
                Actor:       "system", // Will be replaced with actual user when auth is implemented
                Description: fmt.Sprintf("Status changed from %s to %s", oldStatus, status),
                Metadata: map[string]interface{}{
                        "old_status": string(oldStatus),
                        "new_status": string(status),
                },
                OccurredAt: time.Now().UTC(),
        }

        if err := s.repo.AddEvent(ctx, statusEvent); err != nil </span><span class="cov8" title="1">{
                logger.WithError(err).Warn("Failed to record status change event")
                // Don't fail the operation for event recording failures
        }</span>

        <span class="cov8" title="1">logger.WithFields("old_status", string(oldStatus), "new_status", string(status)).
                Info("Incident status updated successfully")
        return nil</span>
}

// AddResponder assigns a responder to an incident.
//
// This method adds a responder to the incident's team and records the
// assignment as an event. The responder ID should be a valid user
// identifier in the system.
//
// Note: In the current implementation, responders are stored in the
// AssigneeID field. Future versions may support multiple responders.
//
// Possible errors:
//   - ErrInvalidInput: incident ID or responder ID is empty
//   - ErrNotFound: incident does not exist
//   - ErrConflict: concurrent modification detected
//   - ErrConnectionFailed: repository is unavailable
//   - ErrTimeout: operation exceeded context deadline
func (s *IncidentService) AddResponder(ctx context.Context, incidentID, responderID string) error <span class="cov8" title="1">{
        if incidentID == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("%w: incident ID cannot be empty", ports.ErrInvalidInput)
        }</span>

        <span class="cov8" title="1">if responderID == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("%w: responder ID cannot be empty", ports.ErrInvalidInput)
        }</span>

        <span class="cov8" title="1">logger := s.logger.WithFields("operation", "add_responder", "incident_id", incidentID, "responder_id", responderID)
        logger.Debug("Adding responder to incident")

        // Get current incident
        incident, err := s.repo.Get(ctx, incidentID)
        if err != nil </span><span class="cov8" title="1">{
                logger.WithError(err).Error("Failed to retrieve incident for responder assignment")
                return err
        }</span>

        <span class="cov8" title="1">oldAssignee := incident.AssigneeID

        // Assign responder (currently single assignee only)
        incident.AssigneeID = responderID
        incident.UpdatedAt = time.Now().UTC()

        // Update incident
        if err := s.repo.Update(ctx, incident); err != nil </span><span class="cov8" title="1">{
                logger.WithError(err).Error("Failed to update incident with responder")
                return err
        }</span>

        // Record responder assignment event
        <span class="cov8" title="1">var description string
        var eventType string
        if oldAssignee == "" </span><span class="cov8" title="1">{
                description = fmt.Sprintf("Responder %s assigned to incident", responderID)
                eventType = "responder_assigned"
        }</span> else<span class="cov8" title="1"> {
                description = fmt.Sprintf("Responder changed from %s to %s", oldAssignee, responderID)
                eventType = "responder_changed"
        }</span>

        <span class="cov8" title="1">responderEvent := &amp;domain.Event{
                ID:          uuid.New().String(),
                IncidentID:  incident.ID,
                Type:        eventType,
                Actor:       "system", // Will be replaced with actual user when auth is implemented
                Description: description,
                Metadata: map[string]interface{}{
                        "responder_id":  responderID,
                        "old_assignee":  oldAssignee,
                        "new_assignee":  responderID,
                        "assignment_at": time.Now().UTC(),
                },
                OccurredAt: time.Now().UTC(),
        }

        if err := s.repo.AddEvent(ctx, responderEvent); err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Warn("Failed to record responder assignment event")
                // Don't fail the operation for event recording failures
        }</span>

        <span class="cov8" title="1">logger.WithFields("old_assignee", oldAssignee, "new_assignee", responderID).
                Info("Responder added to incident successfully")
        return nil</span>
}

// RecordEvent adds a custom event to an incident's audit trail.
//
// This method allows external systems or users to record significant
// events related to an incident. The event is validated before being
// stored and must contain all required fields.
//
// Common event types include:
//   - investigation_started
//   - mitigation_applied
//   - external_communication
//   - escalation
//   - note_added
//
// Possible errors:
//   - ErrInvalidInput: incident ID is empty or event is invalid
//   - ErrNotFound: incident does not exist
//   - ErrConnectionFailed: repository is unavailable
//   - ErrTimeout: operation exceeded context deadline
func (s *IncidentService) RecordEvent(ctx context.Context, incidentID string, event domain.Event) error <span class="cov8" title="1">{
        if incidentID == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("%w: incident ID cannot be empty", ports.ErrInvalidInput)
        }</span>

        <span class="cov8" title="1">logger := s.logger.WithFields("operation", "record_event", "incident_id", incidentID, "event_type", event.Type)
        logger.Debug("Recording custom event for incident")

        // Ensure event references the correct incident
        event.IncidentID = incidentID

        // Generate ID if not provided
        if event.ID == "" </span><span class="cov8" title="1">{
                event.ID = uuid.New().String()
        }</span>

        // Set timestamp if not provided
        <span class="cov8" title="1">if event.OccurredAt.IsZero() </span><span class="cov8" title="1">{
                event.OccurredAt = time.Now().UTC()
        }</span>

        // Validate event
        <span class="cov8" title="1">if err := event.Validate(); err != nil </span><span class="cov8" title="1">{
                logger.WithError(err).Debug("Event validation failed")
                return fmt.Errorf("%w: event validation failed: %v", ports.ErrInvalidInput, err)
        }</span>

        // Check incident exists before adding event
        <span class="cov8" title="1">_, err := s.repo.Get(ctx, incidentID)
        if err != nil </span><span class="cov8" title="1">{
                logger.WithError(err).Error("Failed to verify incident exists before recording event")
                return err
        }</span>

        // Store event
        <span class="cov8" title="1">if err := s.repo.AddEvent(ctx, &amp;event); err != nil </span><span class="cov8" title="1">{
                logger.WithError(err).Error("Failed to record event")
                return err
        }</span>

        <span class="cov8" title="1">logger.WithFields("event_id", event.ID, "event_type", event.Type).
                Info("Event recorded successfully")
        return nil</span>
}

// generateHumanReadableID creates a human-readable incident identifier.
//
// The format is INC-YYYY-NNN where:
//   - INC is the fixed prefix
//   - YYYY is the current year
//   - NNN is a zero-padded sequential number
//
// This method is thread-safe and handles year rollovers automatically.
// The sequence resets to 1 at the beginning of each year.
func (s *IncidentService) generateHumanReadableID() string <span class="cov8" title="1">{
        s.idCounter.mu.Lock()
        defer s.idCounter.mu.Unlock()

        currentYear := time.Now().UTC().Year()

        // Reset sequence if year has changed
        if currentYear != s.idCounter.year </span><span class="cov8" title="1">{
                s.idCounter.year = currentYear
                s.idCounter.sequence = 0
        }</span>

        // Increment sequence
        <span class="cov8" title="1">s.idCounter.sequence++

        // Format as INC-YYYY-NNN
        return fmt.Sprintf("INC-%d-%s", currentYear, s.formatSequence(s.idCounter.sequence))</span>
}

// formatSequence formats a sequence number with leading zeros.
//
// Numbers are zero-padded to 3 digits (001, 002, etc.) up to 999,
// then expand as needed (1000, 1001, etc.).
func (s *IncidentService) formatSequence(seq int) string <span class="cov8" title="1">{
        if seq &lt; 1000 </span><span class="cov8" title="1">{
                return fmt.Sprintf("%03d", seq)
        }</span>
        <span class="cov8" title="1">return strconv.Itoa(seq)</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// Package logging provides structured logging capabilities for the Guvnor incident management platform.
//
// This package configures and manages structured logging using Go's standard library slog,
// providing environment-aware configuration and context propagation for consistent logging
// across the application.
package logging

import (
        "context"
        "fmt"
        "io"
        "log/slog"
        "os"
        "runtime"
        "strings"
        "time"
)

// Environment represents the deployment environment.
type Environment string

// Environment constants define the valid deployment environments.
const (
        Development Environment = "development"
        Production  Environment = "production"
        Test        Environment = "test"
)

// String returns the string representation of the environment.
func (e Environment) String() string <span class="cov8" title="1">{
        return string(e)
}</span>

// IsValid checks if the environment is one of the defined valid environments.
func (e Environment) IsValid() bool <span class="cov8" title="1">{
        switch e </span>{
        case Development, Production, Test:<span class="cov8" title="1">
                return true</span>
        default:<span class="cov8" title="1">
                return false</span>
        }
}

// Config holds the configuration for the logger.
type Config struct {
        Environment Environment `json:"environment"`
        Level       slog.Level  `json:"level"`
        Output      io.Writer   `json:"-"`
        AddSource   bool        `json:"add_source"`
}

// Logger wraps slog.Logger with additional functionality for structured logging.
type Logger struct {
        *slog.Logger
        config Config
}

// DefaultConfig returns a default configuration based on the environment.
func DefaultConfig(env Environment) Config <span class="cov8" title="1">{
        config := Config{
                Environment: env,
                Level:       slog.LevelInfo,
                Output:      os.Stdout,
                AddSource:   false,
        }

        switch env </span>{
        case Development:<span class="cov8" title="1">
                config.Level = slog.LevelDebug
                config.AddSource = true</span>
        case Production:<span class="cov8" title="1">
                config.Level = slog.LevelInfo
                config.AddSource = false</span>
        case Test:<span class="cov8" title="1">
                config.Level = slog.LevelWarn
                config.AddSource = false</span>
        }

        <span class="cov8" title="1">return config</span>
}

// NewLogger creates a new structured logger with the given configuration.
//
// The logger is configured based on the environment:
//   - Development: Pretty console output with debug level and source information
//   - Production: JSON output with info level for machine parsing
//   - Test: JSON output with warn level to reduce noise
//
// Returns a Logger instance or an error if configuration is invalid.
func NewLogger(config Config) (*Logger, error) <span class="cov8" title="1">{
        if !config.Environment.IsValid() </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid environment: %s", config.Environment)
        }</span>

        <span class="cov8" title="1">if config.Output == nil </span><span class="cov8" title="1">{
                config.Output = os.Stdout
        }</span>

        <span class="cov8" title="1">var handler slog.Handler

        handlerOpts := &amp;slog.HandlerOptions{
                Level:     config.Level,
                AddSource: config.AddSource,
        }

        switch config.Environment </span>{
        case Development:<span class="cov8" title="1">
                // Pretty console output for development
                handler = slog.NewTextHandler(config.Output, handlerOpts)</span>
        case Production, Test:<span class="cov8" title="1">
                // JSON output for production and testing (machine parseable)
                handler = slog.NewJSONHandler(config.Output, handlerOpts)</span>
        }

        <span class="cov8" title="1">logger := slog.New(handler)

        return &amp;Logger{
                Logger: logger,
                config: config,
        }, nil</span>
}

// NewFromEnvironment creates a logger using environment variables.
//
// Environment variables:
//   - GUVNOR_ENV: Sets the environment (development, production, test)
//   - GUVNOR_LOG_LEVEL: Sets the log level (debug, info, warn, error)
//   - GUVNOR_LOG_ADD_SOURCE: Enables source information (true, false)
//
// Returns a Logger instance with default configuration if environment variables are not set.
func NewFromEnvironment() (*Logger, error) <span class="cov8" title="1">{
        env := Development
        if envVar := os.Getenv("GUVNOR_ENV"); envVar != "" </span><span class="cov8" title="1">{
                env = Environment(strings.ToLower(envVar))
        }</span>

        <span class="cov8" title="1">config := DefaultConfig(env)

        // Override log level if specified
        if levelVar := os.Getenv("GUVNOR_LOG_LEVEL"); levelVar != "" </span><span class="cov8" title="1">{
                level, err := parseLogLevel(levelVar)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("invalid log level: %w", err)
                }</span>
                <span class="cov8" title="1">config.Level = level</span>
        }

        // Override add source if specified
        <span class="cov8" title="1">if sourceVar := os.Getenv("GUVNOR_LOG_ADD_SOURCE"); sourceVar != "" </span><span class="cov8" title="1">{
                config.AddSource = strings.ToLower(sourceVar) == "true"
        }</span>

        <span class="cov8" title="1">return NewLogger(config)</span>
}

// parseLogLevel converts a string to slog.Level.
func parseLogLevel(level string) (slog.Level, error) <span class="cov8" title="1">{
        switch strings.ToLower(level) </span>{
        case "debug":<span class="cov8" title="1">
                return slog.LevelDebug, nil</span>
        case "info":<span class="cov8" title="1">
                return slog.LevelInfo, nil</span>
        case "warn", "warning":<span class="cov8" title="1">
                return slog.LevelWarn, nil</span>
        case "error":<span class="cov8" title="1">
                return slog.LevelError, nil</span>
        default:<span class="cov8" title="1">
                return slog.LevelInfo, fmt.Errorf("unknown log level: %s", level)</span>
        }
}

// WithContext adds logger to context for propagation.
//
// This allows the logger to be retrieved from context throughout the application
// using FromContext. The logger can be augmented with request-specific fields
// before adding to context.
func (l *Logger) WithContext(ctx context.Context) context.Context <span class="cov8" title="1">{
        return context.WithValue(ctx, loggerKey{}, l)
}</span>

// WithFields returns a new logger with additional structured fields.
//
// This is useful for adding context-specific fields that should be included
// in all log entries from this logger instance.
func (l *Logger) WithFields(fields ...any) *Logger <span class="cov8" title="1">{
        return &amp;Logger{
                Logger: l.Logger.With(fields...),
                config: l.config,
        }
}</span>

// WithRequestID returns a new logger with a request ID field.
//
// This is a convenience method for adding request IDs to log entries,
// which is essential for tracing requests through the system.
func (l *Logger) WithRequestID(requestID string) *Logger <span class="cov8" title="1">{
        return l.WithFields("request_id", requestID)
}</span>

// WithIncidentID returns a new logger with an incident ID field.
//
// This is a convenience method for adding incident IDs to log entries,
// which helps with debugging and auditing incident-related operations.
func (l *Logger) WithIncidentID(incidentID string) *Logger <span class="cov8" title="1">{
        return l.WithFields("incident_id", incidentID)
}</span>

// WithError returns a new logger with an error field.
//
// This is a convenience method for including error information in log entries
// while preserving the error's context and stack trace information.
func (l *Logger) WithError(err error) *Logger <span class="cov8" title="1">{
        return l.WithFields("error", err.Error())
}</span>

// WithDuration returns a new logger with a duration field.
//
// This is useful for logging operation timings and performance metrics.
func (l *Logger) WithDuration(duration time.Duration) *Logger <span class="cov8" title="1">{
        return l.WithFields("duration_ms", duration.Milliseconds())
}</span>

// loggerKey is used as the key for storing logger in context.
type loggerKey struct{}

// FromContext retrieves the logger from context.
//
// If no logger is found in context, returns a default logger configured
// for the current environment. This ensures that logging always works
// even if context propagation fails.
func FromContext(ctx context.Context) *Logger <span class="cov8" title="1">{
        if logger, ok := ctx.Value(loggerKey{}).(*Logger); ok </span><span class="cov8" title="1">{
                return logger
        }</span>

        // Fallback to default logger if not in context
        <span class="cov8" title="1">logger, err := NewFromEnvironment()
        if err != nil </span><span class="cov0" title="0">{
                // Last resort: create a basic logger
                handler := slog.NewTextHandler(os.Stderr, &amp;slog.HandlerOptions{
                        Level: slog.LevelInfo,
                })
                return &amp;Logger{
                        Logger: slog.New(handler),
                        config: DefaultConfig(Development),
                }
        }</span>

        <span class="cov8" title="1">return logger</span>
}

// GetConfig returns the logger's configuration.
//
// This is useful for debugging logger configuration and ensuring
// the logger is configured as expected.
func (l *Logger) GetConfig() Config <span class="cov8" title="1">{
        return l.config
}</span>

// LogOperationStart logs the start of an operation with timing information.
//
// This should be paired with LogOperationEnd to provide complete timing
// information for operations. Returns the start time for use with LogOperationEnd.
func (l *Logger) LogOperationStart(operation string, fields ...any) time.Time <span class="cov8" title="1">{
        start := time.Now()
        allFields := append([]any{"operation", operation, "phase", "start"}, fields...)
        l.Debug("Operation started", allFields...)
        return start
}</span>

// LogOperationEnd logs the completion of an operation with duration.
//
// This should be called with the start time returned from LogOperationStart
// to provide accurate timing information.
func (l *Logger) LogOperationEnd(operation string, start time.Time, err error, fields ...any) <span class="cov8" title="1">{
        duration := time.Since(start)
        allFields := append([]any{
                "operation", operation,
                "phase", "end",
                "duration_ms", duration.Milliseconds(),
        }, fields...)

        if err != nil </span><span class="cov8" title="1">{
                allFields = append(allFields, "error", err.Error())
                l.Error("Operation failed", allFields...)
        }</span> else<span class="cov8" title="1"> {
                l.Info("Operation completed", allFields...)
        }</span>
}

// GetCaller returns information about the calling function.
//
// This is useful for debugging and can be manually added to log entries
// when automatic source information is not sufficient.
func GetCaller(skip int) (file string, line int, function string) <span class="cov8" title="1">{
        pc, file, line, ok := runtime.Caller(skip + 1)
        if !ok </span><span class="cov0" title="0">{
                return "unknown", 0, "unknown"
        }</span>

        <span class="cov8" title="1">fn := runtime.FuncForPC(pc)
        if fn == nil </span><span class="cov0" title="0">{
                return file, line, "unknown"
        }</span>

        <span class="cov8" title="1">return file, line, fn.Name()</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package middleware

import (
        "context"
        "net/http"
        "time"

        "github.com/Studio-Elephant-and-Rope/guvnor/internal/logging"
)

// responseWriter wraps http.ResponseWriter to capture status code and response size.
type responseWriter struct {
        http.ResponseWriter
        statusCode int
        size       int
}

// WriteHeader captures the status code before writing.
func (rw *responseWriter) WriteHeader(code int) <span class="cov8" title="1">{
        rw.statusCode = code
        rw.ResponseWriter.WriteHeader(code)
}</span>

// Write captures the response size and writes the data.
func (rw *responseWriter) Write(b []byte) (int, error) <span class="cov8" title="1">{
        size, err := rw.ResponseWriter.Write(b)
        rw.size += size
        return size, err
}</span>

// LoggingMiddleware logs HTTP requests with structured logging.
//
// For each request, logs:
//   - Request method, path, user agent
//   - Response status code and size
//   - Request duration in milliseconds
//   - Request ID for correlation
//   - Client IP address
//
// Uses different log levels based on response status:
//   - 5xx errors: ERROR level
//   - 4xx errors: WARN level
//   - All others: INFO level
//
// This middleware should be applied after RequestIDMiddleware to ensure
// request IDs are available for correlation.
func LoggingMiddleware(logger *logging.Logger) func(http.Handler) http.Handler <span class="cov8" title="1">{
        return func(next http.Handler) http.Handler </span><span class="cov8" title="1">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                        start := time.Now()

                        // Check if logging should be skipped
                        if skip, ok := r.Context().Value("skip_logging").(bool); ok &amp;&amp; skip </span><span class="cov8" title="1">{
                                next.ServeHTTP(w, r)
                                return
                        }</span>

                        // Get request ID from context
                        <span class="cov8" title="1">requestID := GetRequestIDFromContext(r.Context())

                        // Wrap response writer to capture status and size
                        wrapped := &amp;responseWriter{
                                ResponseWriter: w,
                                statusCode:     http.StatusOK, // Default status
                                size:           0,
                        }

                        // Process request
                        next.ServeHTTP(wrapped, r)

                        // Calculate duration
                        duration := time.Since(start)

                        // Extract client IP
                        clientIP := getClientIP(r)

                        // Create enriched logger with request context
                        logCtx := logger.WithFields(
                                "method", r.Method,
                                "path", r.URL.Path,
                                "status", wrapped.statusCode,
                                "duration_ms", duration.Milliseconds(),
                                "size_bytes", wrapped.size,
                                "client_ip", clientIP,
                                "user_agent", r.UserAgent(),
                        )

                        // Add request ID if available
                        if requestID != "" </span><span class="cov8" title="1">{
                                logCtx = logCtx.WithRequestID(requestID)
                        }</span>

                        // Add query parameters if present
                        <span class="cov8" title="1">if r.URL.RawQuery != "" </span><span class="cov8" title="1">{
                                logCtx = logCtx.WithFields("query", r.URL.RawQuery)
                        }</span>

                        // Log with appropriate level based on status code
                        <span class="cov8" title="1">message := "HTTP request processed"
                        switch </span>{
                        case wrapped.statusCode &gt;= 500:<span class="cov8" title="1">
                                logCtx.Error(message)</span>
                        case wrapped.statusCode &gt;= 400:<span class="cov8" title="1">
                                logCtx.Warn(message)</span>
                        default:<span class="cov8" title="1">
                                logCtx.Info(message)</span>
                        }
                })
        }
}

// getClientIP extracts the client IP address from the request.
//
// Checks headers in order of preference:
//  1. X-Forwarded-For (proxy/load balancer)
//  2. X-Real-IP (nginx)
//  3. RemoteAddr (direct connection)
func getClientIP(r *http.Request) string <span class="cov8" title="1">{
        // Check X-Forwarded-For header (may contain multiple IPs)
        if forwarded := r.Header.Get("X-Forwarded-For"); forwarded != "" </span><span class="cov8" title="1">{
                // Take the first IP in the list
                if idx := len(forwarded); idx &gt; 0 </span><span class="cov8" title="1">{
                        if commaIdx := 0; commaIdx &lt; len(forwarded) </span><span class="cov8" title="1">{
                                for i, char := range forwarded </span><span class="cov8" title="1">{
                                        if char == ',' </span><span class="cov8" title="1">{
                                                commaIdx = i
                                                break</span>
                                        }
                                }
                                <span class="cov8" title="1">if commaIdx &gt; 0 </span><span class="cov8" title="1">{
                                        return forwarded[:commaIdx]
                                }</span>
                        }
                        <span class="cov8" title="1">return forwarded</span>
                }
        }

        // Check X-Real-IP header
        <span class="cov8" title="1">if realIP := r.Header.Get("X-Real-IP"); realIP != "" </span><span class="cov8" title="1">{
                return realIP
        }</span>

        // Fall back to RemoteAddr
        <span class="cov8" title="1">return r.RemoteAddr</span>
}

// HealthCheckSkipMiddleware skips logging for health check endpoints.
//
// Health checks can be very noisy in logs and typically don't provide
// value for debugging. This middleware allows skipping logging for
// specific paths like /health or /ping by setting a context flag.
func HealthCheckSkipMiddleware(paths []string) func(http.Handler) http.Handler <span class="cov8" title="1">{
        skipPaths := make(map[string]bool)
        for _, path := range paths </span><span class="cov8" title="1">{
                skipPaths[path] = true
        }</span>

        <span class="cov8" title="1">return func(next http.Handler) http.Handler </span><span class="cov8" title="1">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                        // Mark health check paths in context
                        if skipPaths[r.URL.Path] </span><span class="cov8" title="1">{
                                ctx := context.WithValue(r.Context(), "skip_logging", true)
                                r = r.WithContext(ctx)
                        }</span>

                        <span class="cov8" title="1">next.ServeHTTP(w, r)</span>
                })
        }
}

// CombinedMiddleware creates a logging middleware that combines logging with health check skipping.
//
// This is a convenience function that applies health check skipping before logging.
// Common health check paths are pre-configured, but additional paths can be specified.
func CombinedLoggingMiddleware(logger *logging.Logger, additionalSkipPaths ...string) func(http.Handler) http.Handler <span class="cov8" title="1">{
        // Default health check paths to skip
        defaultSkipPaths := []string{
                "/health",
                "/healthz",
                "/ping",
                "/ready",
                "/alive",
                "/metrics", // Prometheus metrics can be noisy
        }

        // Combine with additional paths
        allSkipPaths := append(defaultSkipPaths, additionalSkipPaths...)

        return func(next http.Handler) http.Handler </span><span class="cov8" title="1">{
                // Apply health check skipping first, then logging
                return HealthCheckSkipMiddleware(allSkipPaths)(LoggingMiddleware(logger)(next))
        }</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">// Package middleware provides HTTP middleware components for the Guvnor incident management platform.
//
// This package includes middleware for request tracing, logging, and other cross-cutting concerns
// that need to be applied consistently across HTTP endpoints.
package middleware

import (
        "context"
        "crypto/rand"
        "encoding/hex"
        "net/http"
)

// RequestIDHeader is the header name for request IDs.
const RequestIDHeader = "X-Request-ID"

// RequestIDContextKey is used to store request IDs in context.
type RequestIDContextKey struct{}

// RequestIDMiddleware adds a unique request ID to each HTTP request.
//
// The request ID is:
//   - Generated using crypto/rand for uniqueness
//   - Added to the request context for access by handlers
//   - Added to the response header for client tracking
//   - Used existing request ID from header if present and valid
//
// This middleware is essential for distributed tracing and log correlation
// across the incident management platform.
func RequestIDMiddleware(next http.Handler) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                requestID := getOrGenerateRequestID(r)

                // Add request ID to context
                ctx := context.WithValue(r.Context(), RequestIDContextKey{}, requestID)
                r = r.WithContext(ctx)

                // Add request ID to response header
                w.Header().Set(RequestIDHeader, requestID)

                next.ServeHTTP(w, r)
        }</span>)
}

// getOrGenerateRequestID extracts request ID from headers or generates a new one.
func getOrGenerateRequestID(r *http.Request) string <span class="cov8" title="1">{
        // Check if request ID already exists in headers
        if existingID := r.Header.Get(RequestIDHeader); existingID != "" &amp;&amp; isValidRequestID(existingID) </span><span class="cov8" title="1">{
                return existingID
        }</span>

        // Generate new request ID
        <span class="cov8" title="1">return generateRequestID()</span>
}

// generateRequestID creates a new cryptographically secure request ID.
func generateRequestID() string <span class="cov8" title="1">{
        bytes := make([]byte, 8) // 16 character hex string
        if _, err := rand.Read(bytes); err != nil </span><span class="cov0" title="0">{
                // Fallback to a simpler method if crypto/rand fails
                return "req-fallback-" + hex.EncodeToString([]byte("fallback"))[:8]
        }</span>
        <span class="cov8" title="1">return "req-" + hex.EncodeToString(bytes)</span>
}

// isValidRequestID checks if a request ID has a valid format.
//
// Valid request IDs should:
//   - Be non-empty
//   - Be reasonable length (between 4 and 64 characters)
//   - Contain only safe characters (alphanumeric, hyphens, underscores)
func isValidRequestID(id string) bool <span class="cov8" title="1">{
        if len(id) &lt; 4 || len(id) &gt; 64 </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">for _, char := range id </span><span class="cov8" title="1">{
                if !((char &gt;= 'a' &amp;&amp; char &lt;= 'z') ||
                        (char &gt;= 'A' &amp;&amp; char &lt;= 'Z') ||
                        (char &gt;= '0' &amp;&amp; char &lt;= '9') ||
                        char == '-' || char == '_') </span><span class="cov8" title="1">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return true</span>
}

// GetRequestIDFromContext extracts the request ID from the given context.
//
// Returns an empty string if no request ID is found in context.
// This function is safe to call even if the context doesn't contain a request ID.
func GetRequestIDFromContext(ctx context.Context) string <span class="cov8" title="1">{
        if requestID, ok := ctx.Value(RequestIDContextKey{}).(string); ok </span><span class="cov8" title="1">{
                return requestID
        }</span>
        <span class="cov8" title="1">return ""</span>
}

// WithRequestID adds a request ID to the given context.
//
// This is useful for testing or for adding request IDs in contexts where
// the middleware hasn't been applied.
func WithRequestID(ctx context.Context, requestID string) context.Context <span class="cov8" title="1">{
        return context.WithValue(ctx, RequestIDContextKey{}, requestID)
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">// Package server provides HTTP server functionality for the Guvnor incident management platform.
//
// This package implements a production-ready HTTP server with:
//   - Graceful shutdown handling with configurable timeouts
//   - Health check endpoint with system information
//   - Structured logging for all server events
//   - Configuration-driven setup
//   - Signal handling for clean shutdown
//
// The server follows established patterns from the rest of the codebase,
// using the same logging, configuration, and middleware systems.
package server

import (
        "context"
        "encoding/json"
        "fmt"
        "net/http"
        "os"
        "os/signal"
        "syscall"
        "time"

        "github.com/Studio-Elephant-and-Rope/guvnor/internal/config"
        "github.com/Studio-Elephant-and-Rope/guvnor/internal/logging"
        "github.com/Studio-Elephant-and-Rope/guvnor/internal/middleware"
)

// Version information for the server
// These can be set during build time via -ldflags
var (
        Version   = "dev"
        Commit    = "unknown"
        BuildDate = "unknown"
)

// Server represents the HTTP server instance with its configuration and state.
//
// The server maintains references to configuration, logging, and the underlying
// HTTP server. It provides methods for starting, stopping, and graceful shutdown.
type Server struct {
        config     *config.Config
        logger     *logging.Logger
        httpServer *http.Server
        startTime  time.Time
        router     *http.ServeMux
}

// HealthResponse represents the structure of the health check response.
//
// This provides information about the server's operational status,
// version information, and uptime for monitoring and debugging purposes.
type HealthResponse struct {
        Status  string `json:"status"`
        Version string `json:"version"`
        Uptime  string `json:"uptime"`
}

// New creates a new server instance with the provided configuration and logger.
//
// The server is configured but not started. Call Start() to begin accepting
// connections. Returns an error if the configuration is invalid.
func New(cfg *config.Config, logger *logging.Logger) (*Server, error) <span class="cov8" title="1">{
        if cfg == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("configuration cannot be nil")
        }</span>
        <span class="cov8" title="1">if logger == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("logger cannot be nil")
        }</span>

        // Validate configuration
        <span class="cov8" title="1">if err := cfg.Validate(); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid configuration: %w", err)
        }</span>

        <span class="cov8" title="1">server := &amp;Server{
                config:    cfg,
                logger:    logger,
                startTime: time.Now().UTC(),
                router:    http.NewServeMux(),
        }

        // Set up routes
        server.setupRoutes()

        // Create HTTP server with configured timeouts
        server.httpServer = &amp;http.Server{
                Addr:         fmt.Sprintf("%s:%d", cfg.Server.Host, cfg.Server.Port),
                Handler:      server.createHandler(),
                ReadTimeout:  time.Duration(cfg.Server.ReadTimeoutSeconds) * time.Second,
                WriteTimeout: time.Duration(cfg.Server.WriteTimeoutSeconds) * time.Second,
                IdleTimeout:  time.Duration(cfg.Server.IdleTimeoutSeconds) * time.Second,
        }

        return server, nil</span>
}

// Start begins accepting HTTP connections.
//
// This method starts the HTTP server and logs startup information.
// It returns immediately and does not block. Use StartWithGracefulShutdown()
// for a blocking start with signal handling.
func (s *Server) Start() error <span class="cov8" title="1">{
        s.logger.Info("Starting HTTP server",
                "address", s.httpServer.Addr,
                "read_timeout", s.httpServer.ReadTimeout,
                "write_timeout", s.httpServer.WriteTimeout,
                "idle_timeout", s.httpServer.IdleTimeout,
        )

        go func() </span><span class="cov8" title="1">{
                if err := s.httpServer.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        s.logger.WithError(err).Error("HTTP server failed")
                }</span>
        }()

        <span class="cov8" title="1">s.logger.Info("HTTP server started successfully", "address", s.httpServer.Addr)
        return nil</span>
}

// StartWithGracefulShutdown starts the server and blocks until shutdown.
//
// This method starts the HTTP server and sets up signal handling for
// graceful shutdown on SIGTERM and SIGINT. It blocks until the server
// is shut down gracefully or an error occurs.
//
// The shutdown process:
//  1. Stops accepting new connections
//  2. Waits for active connections to finish (with timeout)
//  3. Forces close any remaining connections
//  4. Logs shutdown completion
func (s *Server) StartWithGracefulShutdown() error <span class="cov8" title="1">{
        // Start the server
        if err := s.Start(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start server: %w", err)
        }</span>

        // Set up signal handling for graceful shutdown
        <span class="cov8" title="1">sigChan := make(chan os.Signal, 1)
        signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)

        // Wait for shutdown signal
        sig := &lt;-sigChan
        s.logger.Info("Received shutdown signal", "signal", sig.String())

        // Perform graceful shutdown
        return s.Shutdown()</span>
}

// Shutdown gracefully shuts down the server.
//
// This method stops accepting new connections and waits for active
// connections to finish. It respects the configured timeouts and
// will force shutdown if the timeout is exceeded.
func (s *Server) Shutdown() error <span class="cov8" title="1">{
        s.logger.Info("Initiating graceful shutdown")

        // Create shutdown context with timeout
        // Use the write timeout as a reasonable shutdown timeout
        shutdownTimeout := time.Duration(s.config.Server.WriteTimeoutSeconds) * time.Second
        ctx, cancel := context.WithTimeout(context.Background(), shutdownTimeout)
        defer cancel()

        // Attempt graceful shutdown
        if err := s.httpServer.Shutdown(ctx); err != nil </span><span class="cov8" title="1">{
                s.logger.WithError(err).Error("Error during graceful shutdown, forcing close")

                // Force close if graceful shutdown fails
                if closeErr := s.httpServer.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        s.logger.WithError(closeErr).Error("Error during forced close")
                        return fmt.Errorf("shutdown failed: %w, close failed: %v", err, closeErr)
                }</span>
                <span class="cov8" title="1">return fmt.Errorf("graceful shutdown failed, forced close succeeded: %w", err)</span>
        }

        <span class="cov8" title="1">s.logger.Info("Server shutdown completed gracefully")
        return nil</span>
}

// setupRoutes configures the HTTP routes for the server.
//
// Currently implements:
//   - GET /health - Health check endpoint
//
// Additional routes can be added here as features are implemented.
func (s *Server) setupRoutes() <span class="cov8" title="1">{
        s.router.HandleFunc("/health", s.handleHealth)
}</span>

// createHandler creates the complete HTTP handler chain with middleware.
//
// The middleware chain includes:
//   - Request ID generation
//   - Request logging (with health check skipping)
//   - Route handling
func (s *Server) createHandler() http.Handler <span class="cov8" title="1">{
        // Start with base router
        handler := http.Handler(s.router)

        // Apply middleware in reverse order (last applied is executed first)

        // Logging middleware (with health check skipping)
        handler = middleware.CombinedLoggingMiddleware(s.logger)(handler)

        // Request ID middleware
        handler = middleware.RequestIDMiddleware(handler)

        return handler
}</span>

// handleHealth handles GET /health requests.
//
// Returns a JSON response with:
//   - status: "healthy" (always, unless server is shutting down)
//   - version: Application version from build information
//   - uptime: Duration since server started
//
// This endpoint is designed for load balancer health checks and monitoring.
func (s *Server) handleHealth(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        // Only allow GET requests
        if r.Method != http.MethodGet </span><span class="cov8" title="1">{
                w.Header().Set("Allow", "GET")
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        // Calculate uptime
        <span class="cov8" title="1">uptime := time.Since(s.startTime)

        // Create response
        response := HealthResponse{
                Status:  "healthy",
                Version: getVersionString(),
                Uptime:  uptime.String(),
        }

        // Set response headers
        w.Header().Set("Content-Type", "application/json")
        w.Header().Set("Cache-Control", "no-cache, no-store, must-revalidate")
        w.WriteHeader(http.StatusOK)

        // Encode and send response
        if err := json.NewEncoder(w).Encode(response); err != nil </span><span class="cov0" title="0">{
                s.logger.WithError(err).Error("Failed to encode health response")
                // At this point headers are already sent, so we can't change the status
                // The client will receive a 200 with partial/invalid JSON
        }</span>
}

// GetAddr returns the server's configured address.
//
// This is useful for testing and logging purposes.
func (s *Server) GetAddr() string <span class="cov8" title="1">{
        return s.httpServer.Addr
}</span>

// GetUptime returns the duration since the server started.
//
// This is useful for monitoring and debugging purposes.
func (s *Server) GetUptime() time.Duration <span class="cov8" title="1">{
        return time.Since(s.startTime)
}</span>

// IsRunning returns true if the server is currently running.
//
// This checks if the underlying HTTP server is active.
// Note: This is a best-effort check and may not be 100% accurate
// during rapid start/stop cycles.
func (s *Server) IsRunning() bool <span class="cov8" title="1">{
        return s.httpServer != nil
}</span>

// getVersionString returns the version string with appropriate fallback.
func getVersionString() string <span class="cov8" title="1">{
        if Version == "" || Version == "dev" </span><span class="cov8" title="1">{
                return "development"
        }</span>
        <span class="cov8" title="1">return Version</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
